/* Methods */

/// @dev Returns day of the week (Monday is indicated as 1 and so on) 
#define macro WEEKDAY() = takes (0) returns (0) {
    // Formula: ((timestamp / 86400 + 3) % 7) + 1;
    
    // Input Stack: [timestamp(t)]
    
    0x15180       // [86400, t]
    swap1         // [t,86400]
    div           // [t/86400]
    0x03          // [3, t/86400] 
    add           // [3 + t/86400]
    0x07          // [7, (3+t/86400)]
    swap1         // [(t/86400 + 3), 7]  
    mod           // [(t/86400 + 3) % 7]
    0x01          // [1, (t/86400 + 3)%7]
    add           // [1 + (t/86400 + 3)%7]

    // Return stack: [result]
}

 #define macro IS_LEAP_YEAR() = takes (0) returns (0) {                         
    // Condition 1, C1 = year % 4 == 0
    // Condition 2, C2 = year % 100 != 0 
    // Condition 3, C3 =  year % 400 == 0

    // Formula: C1 && (C2||C3)
    
    // Input stack:  [year]

    0x04        // [4, year]
    dup2        // [year,4,year]
    mod         // [year % 4, year]
    iszero      // [C1,year] 
     
    
    0x64       // [100, C1, year]
    dup3       // [year, 100, C1, year]        
    mod        // [year % 100, C1, year]
    iszero     // [year%100==0, C1, year]   
    not        // [c2,c1, year]
             
    0x190       // [400, C2, C1, year]
    dup4        // [year,400,C2, C1, year]
    mod         // [year%400, C2,C1, year]
    iszero      // [C3,C2,C1,year]
    or          // [(C2||C3),C1, year]
    and         // [(C2||C3) && C1, year]
    
    // Clear stack
    swap1
    pop

    // Return stack: [result]
}


 #define macro DAYS_IN_MONTH() = takes (0) returns (0) {      

    // Input Stack : [month, year]

    
    // Push days in month map: [31,28,31,30,31,30,31,31,30,31,30,31]
    0x1F1C1F1E1F1E1F1F1E1F1E1F // [daysInMonthMap,month, year]
    dup2                       // [month,daysInMonthMap, month, year]
    0x13                       // [19,month, daysInMonthMap, month, year]
    add                        // [monthOffset, daysInMonthMap, month, year]
    byte                       // [daysInMonth, month, year]
    dup3                       // [year, daysInMonth, month, year]
    IS_LEAP_YEAR()             // [isleap(year), daysInMonth, month, year]
    dup3                       // [month, isleap(year), daysInMonth, month, year]
    0x02                       // [2, month, isleap(year), daysInMonth, month, year]
    eq                         // [2==month, isleap(year), daysInMonth, month, year]
 
    and                        // [2==month && isleap(year), daysInMonth, month, year]
    add                        // [2==month && isleap(year) + daysInMonth, month, year]
   
    // Clear stack
    swap2
    pop
    pop

    // Return stack: [result]
 }


 #define macro DATE_TO_EPOCH_DAY() = takes (0) returns (0) {      
 
    // Input stack : [d, m, y]

    // Copy date, month and year to memory
    0x40 mstore
    0x20 mstore
    0x00 mstore     
    
    0x190              // [400]
    0x3                // [3, 400,  ]
    0x20 mload         // [m, 3, 400, ]
    lt                 // [m<3, 400 ]
    0x00 mload         // [y, m<3, 400,  ]
    sub                // [(y - m < 3), 400, ] 
    mod        
    0x60 mstore

    0xafa6d            // [719469]
    0x64               // [100,719469]
    0x60 mload
    div                // [(y - m < 3) % 400 / 100, 719469] 
    0x40 mload         // [d, (y - m < 3) % 400 / 100, 719469] 
    0x301              // [769, (y - m < 3) % 400 / 100, 719469]  
    0xc                // [12, 769, (y - m < 3) % 400 / 100, 719469]   
    0x9                // [9, 12, 769, (y - m < 3) % 400 / 100, 719469]  
    0x20 mload         // [m, 9, 12, 769, (y - m < 3) % 400 / 100, 719469]   
    add                // [m + 9, 12, 769, (y - m < 3) % 400 / 100, 719469]     
    mod                // [m + 9 % 12, 769, (y - m < 3) % 400 / 100, 719469]    
    0xf4ff             // [62719, m + 9 % 12, 769, (y - m < 3) % 400 / 100, 719469]  
    mul                // [62719 * m + 9 % 12, 769, (y - m < 3) % 400 / 100, 719469]   
    add                // [62719 * m + 9 % 12 + 769, (y - m < 3) % 400 / 100, 719469]  
    0xb                // [11, 62719 * m + 9 % 12 + 769, (y - m < 3) % 400 / 100, 719469]    
    shr                // [11 << 62719 * m + 9 % 12 + 769, (y - m < 3) % 400 / 100, 719469]      
    add                // [11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    0x60 mload         // [(y - m < 3) % 400, 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    0x2                // [2, (y - m < 3) % 400, 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    shr                // [2 >> (y - m < 3) % 400, 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    0x16d              // [365, 2 >> (y - m < 3) % 400, 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
     
    0x60 mload         // [(y - m < 3) % 400, 365, 2 >> (y - m < 3) % 400, 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 

    mul                // [(y - m < 3) % 400 * 365, 2 >> (y - m < 3) % 400, 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    add                // [(y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400, 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    add                // [(y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400 + 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    sub                // [(y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400 + 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100,719469] 
    0x23ab1            // [(y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400 + 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    0x190              // [146097, (y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400 + 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    0x00 mload         // [y, 146097, (y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400 + 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    div                // [y / 146097, (y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400 + 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    mul                // [y / 146097 * (y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400 + 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    add                // [y / 146097 * (y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400 + 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100, 719469] 
    sub                // [y / 146097 * (y - m < 3) % 400 * 365 + 2 >> (y - m < 3) % 400 + 11 << 62719 * m + 9 % 12 + 769 + (y - m < 3) % 400 / 100 - 719469] 

    // Return stack:  // [result]
 }